---
title: 'Modeling the impact of vaccination'
output:
  html_document: default
  html_notebook: default
  fig.asp: 0.618
  fig.width: 6
  fig.align: center
  html_notebook: default
  out.width: 70%
  pdf_document: default
editor_options: 
  chunk_output_type: console
---
# Model checking -- population size
```{r}
rm(list=ls())
country <- "Nepal"
library( deSolve )
library( tidyverse )
source( "codes/func.R" )
source( "codes/params.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )

tstop <- 200
nday <- 365
dt <- 365
times <- seq( 0, tstop*nday, dt )

params <- c( 0.05, 1, 1, 1 )
compute_R0_water( params )
res <- rk( y=init_val, times=times, func=cholera_sirw, parms=params, method="rk45dp7", hmax=4, hmin=0.2 )
if( dt != 365 ){
  thin_row <- seq( 1 , (tstop*nday/dt+1), by=nday/dt )
  res <- res[ thin_row, ]
}
res <- res[ , -1 ]  # remove the first column indicating time
S <- rowSums( res[ , index_s ] )
I <- rowSums( res[ , index_i ] )
R <- rowSums( res[ , index_r ] )
V <- rowSums( res[ , index_v ] )
B <- res[ , index_b ]

N <- S + I + R + V

df <- data.frame( t=0:tstop, S=S, I=I, R=R, V=V, N=N, B=B )
df_long <- tidyr::gather( df, inf_status, num, -t )
# res$inf_status <- factor( res$inf_status, levels=c("S","I","R") )

d <- filter( df_long, inf_status == c("N","S") )
ggplot( d ) +
  geom_line( aes( x=t, y=num, color=inf_status ) ) +
  labs( x="Time (year)", y = "Number", color = "State")

```

# Model checking -- population distribution by age group
```{r}
ag <- lapply( 1:10, function(x) rowSums( res[ , iag[[x]] ] ) )
df <- data.frame( t=0:tstop, ag_0_1=ag[[1]], ag_1_4=ag[[2]], ag_5_14=ag[[3]] )
d <- tidyr::gather( df, age_grp, num, -t )
# d <- filter( df_long, age_grp == "ag_0_1" )
ggplot( d ) +
  geom_line( aes( x=t, y=num, color=age_grp ) ) +
  labs( x="Time (year)", y = "Number", color = "Age group")
```

# Equilibrium distribution of age groups
```{r}
N <- sapply( iag, function(x) rowSums( res[ , x ] ) ) 
tail( N, 1 )

library(rootSolve)
sstate <- runsteady(y=init_val, func=cholera_sirw, parms=params )
sstate$y
sapply( iag, function(x) sum( sstate$y[ x ] ) )
```

# Equilibrium distribution
```{r}
init_val <- dput(tail(out,1)[2:(4*num_age_grp+1)])
init_val <- c( init_val, rep(0,2*num_age_grp) )
dput( init_val )

library(rootSolve)
ss <- runsteady(y=init_val, func=cholera_sirw, parms=params )
```

# Model check -- annual incidence by age group
```{r}
library( tidyverse )
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library(Rcpp)
sourceCpp( "codes/cholera_sirw.cpp" )

tstop <- 300
times <- seq( 0, tstop*365, 365 )
params <- c( 0.1, 1, 1, 1 )
compute_R0_water( params )
# Integrate ODEs
res <- rk( y=init_val, times=times, func=cholera_sirw, parms=params, method="rk45dp7", hmax=4, hmin=0.1 )
res <- res[ , -1 ] # remove the first column indicating time
S <- res[ , index_s ]
I <- res[ , index_i ] 
R <- res[ , index_r ] 
V <- res[ , index_v ] 
CI <- res[ , index_ci ] 
CV <- res[ , index_cv ] 
B <- res[ , index_b ]
N <- S + I + R + V
annual_inc <- CI[2:nrow(CI),] - CI[1:(nrow(CI)-1),]
pyo <- (N[1:tstop,] + N[2:(tstop+1),])/2 # beginning of the two consecutive years  
annual_inc_per_person <- annual_inc / pyo
# tail( annual_inc_per_person, 1 )
ir <- tail( annual_inc_per_person, 1 )
pop <- tail( N, 1 )
inc_pyo <- ir*1e5
inc_pyo  
  

inc_model( params=params, fun=cholera_sirw, tstop=300, pyo=1e5 )
  
```

# Maximum likelihood parameter estimation
```{r}
rm( list=ls() )
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library(Rcpp)
library(optimx)
# sourceCpp( "codes/cholera_sir_cpp.cpp" )
sourceCpp( "codes/cholera_sir_smpl_cpp.cpp" )
# tstop <- 600
lower_bounds <- c( 1e-3, 1e-3, 1e-3, 1e-3)
upper_bounds <- c( 1e3, 1e3, 1e3, 1e3 )
start <- c( 1.3, 10, 1, 0.1 )
tic <- Sys.time()
fit <- optimx( par = start, 
               fn = neg_log_lik,
               lower = lower_bounds, 
               upper = upper_bounds,
               method = "nlminb",
               itnmax = 100,
               control = list(trace=5), 
               data = inc_obs_Jakarta )
elapsed <- Sys.time() - tic

params <- sapply( 1:4, function(x) eval(parse(text=paste0("fit$p",x)))) 
# R0_approx = beta*
#   (chi_1*0.01973551 + chi_2*0.07851448 + chi_3*0.1938802 + chi_4*( 0.1886538 + 0.1818183 + 0.1708433 +  0.1497457 +  0.1105314 +  0.05792751 +  0.01713539)
# x <- seq( 0.14, 0.2, 0.01)
# y<- x
# for( i in seq_along(x)){
#   cat( "i = ",i )
#   y[i]<- neg_log_lik( param=x[i], tstop = 200 )
#   cat( ", par = ", x[i], ", nll = ",y[i],"\n")
# }
# fit_list[[i]] <- fit
# 
# obj <- list( fit_results = fit_list, init_pop = y0, par_start = start_pool, t_stop = t_stop )
# obj_name <- paste0( "data/fit_tstop_", t_stop, ".rds" )
# saveRDS( obj, obj_name )
```


# Markov Chain Monte Carlo parameter estimation 
```{r}
rm( list=ls() )
source( "codes/params.R" )
source( "codes/func.R" )
library(Rcpp)
sourceCpp( "codes/cholera_sir_cpp.cpp" )
sourceCpp( "codes/cholera_sir_smpl_cpp.cpp" )
start <- c( 2.8, 1, 0.1, 1 )
tic <- Sys.time()
samp <- run_MCMC( startvalue = start, iter=10000, scale=c(0.005,0.1,0.1,0.1) )
Sys.time() - tic
samp$acceptance_ratio
hist(samp$theta[,1], main = "theta_1")
acf(samp$theta)
```

# Reverse engineering
```{r}
rm( list=ls() )
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sir_cpp.cpp" )
sourceCpp( "codes/cholera_sir_smpl_cpp.cpp" )
# Generate data
params_true <- c( 1.3, 1, 3, 0.4 )
# ir <- annual_inc_steady( params=params_true )
ir <- annual_inc_tstop( params=params_true, fun=cholera_sir_cpp, tstop=60 )
inc_mean <- ir$annual_inc_pyo*ir$steady_pop/sum(ir$steady_pop)*1e5 # assume a population of 100,000
inc_sample <- rpois( length(inc_mean), inc_mean ) #sample
# reset global variable b/c the log_posterior function needs a global variables, inc_obs
inc_obs[1:3] <- inc_sample[1:3] # <1 yo, 1-4 yo, 5-14 yo
inc_obs[4] <- sum( inc_sample[4:10] ) # 15-64 yo
inc_obs <- round( inc_obs )
start <- c( 0.8, 1, 0.5, 1 )

# tic <- Sys.time()
# mcmc <- run_MCMC( data=inc_obs, fun=cholera_sir_cpp, startvalue=start, iter=10, scale=c(0.01,0.2,0.2,0.2) )
# Sys.time() - tic
# mcmc$acceptance_ratio
# hist(mcmc$theta[,1], main = "theta_1")
# acf(mcmc$theta)

library( adaptMCMC )
mcmc_adt <- MCMC( p=log_posterior, n=100, init=start, scale=c(0.01,0.2,0.2,0.2), adapt=TRUE, acc.rate=0.234, fun=cholera_sir_cpp, data=inc_obs, tstop=60, pyo=1e5, maxsteps=500 )
# tic <- Sys.time()
# Confirm reverse engineering results
d <- readRDS("out/res.rds")
plot(d$samples[,1],type="l")
dd <- d$samples[1e5:2e5,]
apply( dd, 2, mean )
# > apply( dd, 2, mean )
# [1] 1.2361161 0.9054116 3.1729030 0.465244
```

# Fitting to incidence data
```{r}
# Pakistan
# Somalia
# Sudan
# Yemen
# Thailand
# Bangladesh
# India
# Myanmar
# Nepal
# Malaysia
# Papua New Guinea
# Philippines

rm( list=ls() )
country <- "Malaysia"
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )

start <- c( 0.2, 1, 1, 1 )

library( adaptMCMC )

tic <- Sys.time()
res <- MCMC( p=log_posterior, n=5e4, init=start, scale=c(0.01,0.1,0.1,0.1), adapt=TRUE, acc.rate=0.234, fun=cholera_sirw, data=inc_obs, tstop=80*365, pyo=1e5 )

Sys.time() - tic

plot(res$samples[,1],type="l")

tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res, paste0( "out/", country, "_fit_", tstamp, ".rds") )
```
# Posterior predictive check
```{r}
rm( list=ls() )
country <- "Nepal"
source( "codes/params.R" ) #
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )
tsteady <- 80*365 # in terms of year
fit <- readRDS( "out/Nepal_fit_20190726T070759.rds" )
# Nepal_fit_20190726T070759
set.seed(0)
samples <- fit$samples[sample(3e4:5e4,200),]
ppv <- data.frame( matrix( NA, nrow=nrow(samples), ncol=4 ) ) # posterior predictive values 
for( i in 1:nrow(samples) ){
    inc_mean <- inc_model( params=samples[i,], fun=cholera_sirw, tstop=tsteady, pyo=1e5 )
    ppv[i,] <- rpois( length(inc_mean), lambda=inc_mean )
    
}
names(ppv) <- c( "<1", "1-4", "5-14", "15+" )
ppv_df <- tidyr::gather( ppv, age_group, inc )
ppv_df$age_group <- factor( ppv_df$age_group, levels=c("<1", "1-4", "5-14", "15+") )
dat <- data.frame( age_group = c("<1", "1-4", "5-14", "15+"), inc=inc_obs )
library(ggplot2)
ggplot( data=ppv_df, aes(x=age_group,y=inc) ) +
  geom_boxplot() + 
  geom_jitter( width=0.25, alpha=0.2 ) +
  geom_point( data=dat, aes(x=age_group,y=inc), color='red', size=2, inherit.aes=FALSE ) +
  labs( x="Age group", y="Cholera incidence per 100000 person-years" ) +
  theme_classic() +
  theme( panel.grid.major = element_line( colour="#f0f0f0" ) )

# ggsave( "figs/Nepal_case_incidence_ppv.png", width=3.4*2, height=2.5*2, units="in" )
```

# Model checking -- population size
```{r}
country <- "Nepal"
source( "codes/params.R" ) #
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )

fit <- readRDS( "out/Nepal_fit_20190726T070759.rds" )

tsteady <- 10 
cov_vacc_campaign <- c( 0, rep(0.9,nag-1) ) # <1 is not vaccinatied
vacc_campaign <- TRUE
dur_post_vacc <- 60
tstop <- tsteady + dur_post_vacc  
start_vacc_campaign <- tsteady
dur_vacc_campaign <- 30
stop_vacc_campaign <- start_vacc_campaign + dur_vacc_campaign

set.seed(0)
samples <- fit$samples[sample(3e4:5e4,200),]
params <- samples[i,]

compute_R0_water( params )

res <- incidence( params=params, fun=cholera_sirw, tstop=tstop )

df <- data.frame( t=round(seq(0,tstop,365)/365), S=rowSums(res$S), I=rowSums(res$I), R=rowSums(res$R), V=rowSums(res$V), N=rowSums(res$N), B=res$B, CI=rowSums(res$CI), CV=rowSums(res$CV) )
df_long <- tidyr::gather( df, inf_status, num, -t )
# res$inf_status <- factor( res$inf_status, levels=c("S","I","R") )
d <- df_long
d <- dplyr::filter( df_long, inf_status %in% c("I","V","CV","N") )
library(ggplot2)
ggplot( d ) +
  geom_line( aes( x=t, y=num, color=inf_status ) ) +
  labs( x="Time (year)", y = "Fraction", color = "State")

```


# Vaccine impact evaluation
```{r}
rm( list=ls() )
country <- "Nepal"
source( "codes/params.R" ) #
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )
tsteady <- 80*365 # in terms of year
dur_post_vacc <- 10*365
tstop <- tsteady + dur_post_vacc  
start_vacc_campaign <- tsteady
dur_vacc_campaign <- 14.0
stop_vacc_campaign <- start_vacc_campaign + dur_vacc_campaign
size_ref_pop <- 1e5
fit <- readRDS( "out/Nepal_fit_20190726T070759.rds" )
# Nepal_fit_20190726T070759
set.seed(0)
samples <- fit$samples[sample(3e4:5e4,200),]
scenario <- expand.grid( cov_vacc = c(seq(0, 0.9, 0.1), 0.99),
                         vacc_campaign = TRUE )
CI_10y <- data.frame( matrix( NA, nrow=nrow(scenario), ncol=nrow(samples) ) )
CV_10y <- CI_10y
for( i in 1:nrow(scenario) ){
  cat( "i =", i, "\n" )
  cov_vacc_campaign <- c( 0, rep(scenario$cov_vacc[i], nag-1) ) # <1 is not vaccinatied
  vacc_campaign <- scenario$vacc_campaign[i]
  for( j in 1:nrow(samples) ){
    # cat( "j =", j, "\n" )
    res <- incidence( params=samples[j,], fun=cholera_sirw, tstop=tstop )
    # cumulative incidence over dur_post_vacc days per ref_pop
    CI_10y[i,j] <- 
      ( sum(res$CI[round(tstop/365),]) - sum(res$CI[round(tsteady/365),]) ) / sum(res$N[round(tsteady/365),])*size_ref_pop
    CV_10y[i,j] <- 
      ( sum(res$CV[round(tstop/365),]) - sum(res$CV[round(tsteady/365),]) ) / sum(res$N[round(tsteady/365),])*size_ref_pop
  }
}
tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )

# saveRDS( CI_10y, paste0( "out/", country, "_CI_10y_", tstamp, ".rds") )
write.csv( cbind( scenario, CI_10y  ), paste0( "out/", country, "_CI_10y_", tstamp, ".csv"), row.names = FALSE )
write.csv( cbind( scenario, CV_10y  ), paste0( "out/", country, "_CV_10y_", tstamp, ".csv"), row.names = FALSE )

CI_10y <- CI_10y[,-c(1,2)] 
CV_10y <- CV_10y[,-c(1,2)] 
ove <- matrix( NA, nrow=(nrow(scenario)-1), ncol=nrow(samples) ) # 
case_averted <- ove
for( i in 1:nrow(ove) ){
 ove[i,] <- as.double( 100*(CI_10y[1,] - CI_10y[i+1,])/CI_10y[1,] ) # index 1 indicates zero vaccine coverage (reference case)
 case_averted[i,] <- as.double( 100*(CI_10y[1,] - CI_10y[i+1,]) / CV_10y[i+1,] )
}

ove_summary <- as.data.frame( apply( ove, 1, quantile, probs=c(0.025,0.25,0.5,0.75,0.975) ) )
case_averted_summary <- as.data.frame( apply( case_averted, 1, quantile, probs=c(0.025,0.25,0.5,0.75,0.975) ) )
names( ove_summary ) <- as.character( scenario$cov_vacc[2:11] )
names( case_averted_summary ) <- as.character(scenario$cov_vacc[2:11] )
pct <- data.frame( percentile = as.character( c(0.25,25,50,75,97.5) ) )
ove_summary <- cbind( pct, ove_summary )
case_averted_summary <- cbind( pct, case_averted_summary )
write.csv( ove_summary, paste0( "out/", country, "_ove_10y_", tstamp, ".csv"), row.names = FALSE )
write.csv( case_averted_summary, paste0( "out/", country, "_case_averted_10y_", tstamp, ".csv"), row.names = FALSE )
```

# Vaccine impact multiple countries
```{r}
rm( list=ls() )
source( "codes/params.R" ) #
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )
country_list <- c("Thailand","Bangladesh","India","Myanmar","Nepal")

# params <- c(1.3,5,1.8,0.4)
tsteady <- 80*365 # vaccinatino begins when the system reaches the steady state
dur_post_vacc <- 10*365
tstop <- tsteady + dur_post_vacc  
start_vacc_campaign <- tsteady
dur_vacc_campaign <- 14.0
stop_vacc_campaign <- start_vacc_campaign + dur_vacc_campaign
size_ref_pop <- 1e5

for( n in 1:length(country_list) ){
  country <- country_list[n];
  file <- list.files( path="out/.", pattern=paste0("^", country, "_fit", "*"), full.names=TRUE )
# d <- readRDS( "out/Nepal_fit_20190726T070759.rds" )
  fit <- readRDS( file[1] )
  set.seed(9)
  samples <- fit$samples[sample(3e4:5e4,200),]
  scenario <- expand.grid( cov_vacc = seq( 0, 1, 0.1 ),
                           vacc_campaign = TRUE )
  CI_10y <- data.frame( matrix( NA, nrow=nrow(scenario), ncol=nrow(samples) ) )
  CI_10y <- cbind( scenario, CI_10y  )
  CV_10y <- CI_10y
  for( i in 1:nrow(scenario) ){
    cat( "i =", i, "\n" )
    cov_vacc_campaign <- c( 0, rep(scenario$cov_vacc[i], nag-1) )
    vacc_campaign <- scenario$vacc_campaign[i]
    for( j in 1:nrow(samples) ){
      # cat( "j =", j, "\n" )
      res <- incidence( params=samples[ j, ], fun=cholera_sirw, tstop=tstop )
      # cumulative incidence over dur_post_vacc days per ref_pop
      CI_10y[ i, (j+ncol(scenario)) ] <- 
        ( sum(res$CI[round(tstop/365),]) - sum(res$CI[round(tsteady/365),]) ) / sum(res$N[round(tsteady/365),])*size_ref_pop
      CV_10y[ i, (j+ncol(scenario)) ] <- 
        ( sum(res$CV[round(tstop/365),]) - sum(res$CV[round(tsteady/365),]) ) / sum(res$N[round(tsteady/365),])*size_ref_pop
    }
  }
  tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
  write.csv( CI_10y, paste0( "out/", country, "_CI_10y_", tstamp, ".csv"), row.names = FALSE )
  write.csv( CI_10y, paste0( "out/", country, "_CV_10y_", tstamp, ".csv"), row.names = FALSE )
  
  CI_10y <- CI_10y[,-c(1,2)] 
  CV_10y <- CV_10y[,-c(1,2)] 
  ove <- matrix( NA, nrow=(nrow(scenario)-1), ncol=nrow(samples) )
  case_averted <- ove
  for( i in 1:nrow(ove) ){
   ove[i,] <- as.double( 100*(CI_10y[1,] - CI_10y[i+1,])/CI_10y[1,] ) # index 1 indicates zero vaccine coverage (reference case)
   case_averted[i,] <- as.double( 100*(CI_10y[1,] - CI_10y[i+1,]) / CV_10y[i+1,] )
   
  }
  ove_summary <- as.data.frame( apply( ove, 1, quantile, probs=c(0.025,0.25,0.5,0.75,0.975) ) )
  case_averted_summary <- as.data.frame( apply( case_averted, 1, quantile, probs=c(0.025,0.25,0.5,0.75,0.975) ) )
  
  names(ove_summary) <- as.character(scenario$cov_vacc[2:11])
  names(case_averted_summary) <- as.character(scenario$cov_vacc[2:11])
  pct <- data.frame( percentile = as.character(c(0.25,25,50,75,97.5)) )
  ove_summary <- cbind( pct, ove_summary )
  case_averted_summary <- cbind( pct, case_averted_summary )
  write.csv( ove_summary, paste0( "out/", country, "_ove_10y_", tstamp, ".csv"), row.names = FALSE )
  write.csv( case_averted_summary, paste0( "out/", country, "_case_averted_10y_", tstamp, ".csv"), row.names = FALSE )
}

```


#
```{r}
library(coda)
chain<- mcmc(samp$samples)
summary(chain)
plot(chain)
library(BayesianTools)
correlationPlot(data.frame(chain))
combinedchains = mcmc.list(chain, chain2)
plot(combinedchains)
gelman.diag(combinedchains)
gelman.plot(combinedchains)

```


#Parallel 
```{r}
library(adaptMCMC)
samp <- MCMC( log_posterior, n=1000, init=start, scale=c(0.005,0.1,0.1,0.1), adapt=FALSE)
samp_adt <- MCMC( p=log_posterior, n=2000, init=start, scale=c(0.01,0.2,0.2,0.2), adapt=TRUE, acc.rate=0.234 )
library(coda)
hist( samp_adt$samples[1000:2000,1] )
hist( samp_adt$samples[1000:2000,2] )
hist( samp_adt$samples[1000:2000,3] )
hist( samp_adt$samples[1000:2000,4] )
str(samp)
summary(samp_adt$samples)
plot( samp_adt$samples[,2] )

## ----------------------
## plot density and samples

x1 <- seq(-15, 15, length=80)
x2 <- seq(-15, 15, length=80)
x3 <- seq(-15, 15, length=80)
x4 <- seq(-15, 15, length=80)

d.banana <- matrix(apply(expand.grid(x1, x2), 1,  p.log), nrow=80)

par(mfrow=c(1,2))
image(x1, x2, exp(d.banana), col=cm.colors(60), asp=1, main="no adaption")
contour(x1, x2, exp(d.banana), add=TRUE, col=gray(0.6))
lines(samp.1$samples, type='b', pch=3)

image(x1, x2, exp(d.banana), col=cm.colors(60), asp=1, main="with adaption")
contour(x1, x2, exp(d.banana), add=TRUE, col=gray(0.6))
lines(samp.2$samples, type='b', pch=3)
```

```{r}
# out <- rk( y=yini, times=t_steps, func=derivs, parms=pars, method="rk45ck" )
# > class(out)
# [1] "deSolve" "matrix" 
class(out) <- "matrix" # without this, dplyr functions get error
out <- tbl_df( out )
colnames( out ) <- c( "t", "S", "I", "R" )
out <- gather( out, inf_status, num, -t )
out$inf_status <- factor( out$inf_status, levels=c("S","I","R") )

out <- filter( out, inf_status == "I" )

ggplot( out ) + 
    geom_line( aes( x=t, y=num, color=inf_status ) ) +
    geom_line( aes( x=t, y=num ), color="red" ) +
    scale_colour_manual( values=c(S="blue",I="red",R="green") ) +
    scale_y_continuous( limits=c(0,520) ) +
    scale_x_continuous( limits=c(0,30) ) +
    labs( x="Time (year)", y="Number of infected people" )
    labs( x="Time (year)", y="Number of infected people", color="Infection status" )
    theme( legend.position=c(0.85,0.45) ) +
    annotate( "text", label=paste0("beta == ", beta), parse=T, x=100, y=1000, size=4, colour="red" ) +
    annotate( "text", label=paste0("gamma == ", gamma), parse=T, x=122, y=1000, size=4, colour="red" )

# ggsave( "sir_i_bir_seas_10-24yr.png" )
```
