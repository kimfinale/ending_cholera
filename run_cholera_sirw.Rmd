---
title: 'Modeling the impact of vaccination'
output:
  html_document: default
  html_notebook: default
  fig.asp: 0.618
  fig.width: 6
  fig.align: center
  html_notebook: default
  out.width: 70%
  pdf_document: default
editor_options: 
  chunk_output_type: console
---
# Model checking -- population size
```{r}
rm(list=ls())
country <- "Nepal"
library( deSolve )
library( tidyverse )
source( "codes/func.R" )
source( "codes/params.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )

tstop <- 200
nday <- 365
dt <- 365
times <- seq( 0, tstop*nday, dt )

params <- c( 0.05, 1, 1, 1 )
compute_R0_water( params )
res <- rk( y=init_val, times=times, func=cholera_sirw, parms=params, method="rk45dp7", hmax=4, hmin=0.2 )
if( dt != 365 ){
  thin_row <- seq( 1 , (tstop*nday/dt+1), by=nday/dt )
  res <- res[ thin_row, ]
}
res <- res[ , -1 ]  # remove the first column indicating time
S <- rowSums( res[ , index_s ] )
I <- rowSums( res[ , index_i ] )
R <- rowSums( res[ , index_r ] )
V <- rowSums( res[ , index_v ] )
B <- res[ , index_b ]

N <- S + I + R + V

df <- data.frame( t=0:tstop, S=S, I=I, R=R, V=V, N=N, B=B )
df_long <- tidyr::gather( df, inf_status, num, -t )
# res$inf_status <- factor( res$inf_status, levels=c("S","I","R") )

d <- filter( df_long, inf_status == c("N","S") )
ggplot( d ) +
  geom_line( aes( x=t, y=num, color=inf_status ) ) +
  labs( x="Time (year)", y = "Number", color = "State")

```

# Model checking -- population distribution by age group
```{r}
ag <- lapply( 1:10, function(x) rowSums( res[ , iag[[x]] ] ) )
df <- data.frame( t=0:tstop, ag_0_1=ag[[1]], ag_1_4=ag[[2]], ag_5_14=ag[[3]] )
d <- tidyr::gather( df, age_grp, num, -t )
# d <- filter( df_long, age_grp == "ag_0_1" )
ggplot( d ) +
  geom_line( aes( x=t, y=num, color=age_grp ) ) +
  labs( x="Time (year)", y = "Number", color = "Age group")
```

# Equilibrium distribution of age groups
```{r}
N <- sapply( iag, function(x) rowSums( res[ , x ] ) ) 
tail( N, 1 )

library(rootSolve)
sstate <- runsteady(y=init_val, func=cholera_sirw, parms=params )
sstate$y
sapply( iag, function(x) sum( sstate$y[ x ] ) )
```

# Equilibrium distribution
```{r}
init_val <- dput(tail(out,1)[2:(4*num_age_grp+1)])
init_val <- c( init_val, rep(0,2*num_age_grp) )
dput( init_val )

library(rootSolve)
ss <- runsteady(y=init_val, func=cholera_sirw, parms=params )
```

# Model check -- annual incidence by age group
```{r}
library( tidyverse )
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library(Rcpp)
sourceCpp( "codes/cholera_sirw.cpp" )

tstop <- 300
times <- seq( 0, tstop*365, 365 )
params <- c( 0.1, 1, 1, 1 )
compute_R0_water( params )
# Integrate ODEs
res <- rk( y=init_val, times=times, func=cholera_sirw, parms=params, method="rk45dp7", hmax=4, hmin=0.1 )
res <- res[ , -1 ] # remove the first column indicating time
S <- res[ , index_s ]
I <- res[ , index_i ] 
R <- res[ , index_r ] 
V <- res[ , index_v ] 
CI <- res[ , index_ci ] 
CV <- res[ , index_cv ] 
B <- res[ , index_b ]
N <- S + I + R + V
annual_inc <- CI[2:nrow(CI),] - CI[1:(nrow(CI)-1),]
pyo <- (N[1:tstop,] + N[2:(tstop+1),])/2 # beginning of the two consecutive years  
annual_inc_per_person <- annual_inc / pyo
# tail( annual_inc_per_person, 1 )
ir <- tail( annual_inc_per_person, 1 )
pop <- tail( N, 1 )
inc_pyo <- ir*1e5
inc_pyo  
  

inc_model( params=params, fun=cholera_sirw, tstop=300, pyo=1e5 )
  
```

# Maximum likelihood parameter estimation
```{r}
rm( list=ls() )
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library(Rcpp)
library(optimx)
# sourceCpp( "codes/cholera_sir_cpp.cpp" )
sourceCpp( "codes/cholera_sir_smpl_cpp.cpp" )
# tstop <- 600
lower_bounds <- c( 1e-3, 1e-3, 1e-3, 1e-3)
upper_bounds <- c( 1e3, 1e3, 1e3, 1e3 )
start <- c( 1.3, 10, 1, 0.1 )
tic <- Sys.time()
fit <- optimx( par = start, 
               fn = neg_log_lik,
               lower = lower_bounds, 
               upper = upper_bounds,
               method = "nlminb",
               itnmax = 100,
               control = list(trace=5), 
               data = inc_obs_Jakarta )
elapsed <- Sys.time() - tic

params <- sapply( 1:4, function(x) eval(parse(text=paste0("fit$p",x)))) 
# R0_approx = beta*
#   (chi_1*0.01973551 + chi_2*0.07851448 + chi_3*0.1938802 + chi_4*( 0.1886538 + 0.1818183 + 0.1708433 +  0.1497457 +  0.1105314 +  0.05792751 +  0.01713539)
# x <- seq( 0.14, 0.2, 0.01)
# y<- x
# for( i in seq_along(x)){
#   cat( "i = ",i )
#   y[i]<- neg_log_lik( param=x[i], tstop = 200 )
#   cat( ", par = ", x[i], ", nll = ",y[i],"\n")
# }
# fit_list[[i]] <- fit
# 
# obj <- list( fit_results = fit_list, init_pop = y0, par_start = start_pool, t_stop = t_stop )
# obj_name <- paste0( "data/fit_tstop_", t_stop, ".rds" )
# saveRDS( obj, obj_name )
```


# Markov Chain Monte Carlo parameter estimation 
```{r}
rm( list=ls() )
source( "codes/params.R" )
source( "codes/func.R" )
library(Rcpp)
sourceCpp( "codes/cholera_sir_cpp.cpp" )
sourceCpp( "codes/cholera_sir_smpl_cpp.cpp" )
start <- c( 2.8, 1, 0.1, 1 )
tic <- Sys.time()
samp <- run_MCMC( startvalue = start, iter=10000, scale=c(0.005,0.1,0.1,0.1) )
Sys.time() - tic
samp$acceptance_ratio
hist(samp$theta[,1], main = "theta_1")
acf(samp$theta)
```

# Reverse engineering
```{r}
rm( list=ls() )
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sir_cpp.cpp" )
sourceCpp( "codes/cholera_sir_smpl_cpp.cpp" )
# Generate data
params_true <- c( 1.3, 1, 3, 0.4 )
# ir <- annual_inc_steady( params=params_true )
ir <- annual_inc_tstop( params=params_true, fun=cholera_sir_cpp, tstop=60 )
inc_mean <- ir$annual_inc_pyo*ir$steady_pop/sum(ir$steady_pop)*1e5 # assume a population of 100,000
inc_sample <- rpois( length(inc_mean), inc_mean ) #sample
# reset global variable b/c the log_posterior function needs a global variables, inc_obs
inc_obs[1:3] <- inc_sample[1:3] # <1 yo, 1-4 yo, 5-14 yo
inc_obs[4] <- sum( inc_sample[4:10] ) # 15-64 yo
inc_obs <- round( inc_obs )
start <- c( 0.8, 1, 0.5, 1 )

# tic <- Sys.time()
# mcmc <- run_MCMC( data=inc_obs, fun=cholera_sir_cpp, startvalue=start, iter=10, scale=c(0.01,0.2,0.2,0.2) )
# Sys.time() - tic
# mcmc$acceptance_ratio
# hist(mcmc$theta[,1], main = "theta_1")
# acf(mcmc$theta)

library( adaptMCMC )
mcmc_adt <- MCMC( p=log_posterior, n=100, init=start, scale=c(0.01,0.2,0.2,0.2), adapt=TRUE, acc.rate=0.234, fun=cholera_sir_cpp, data=inc_obs, tstop=60, pyo=1e5, maxsteps=500 )
# tic <- Sys.time()
# Confirm reverse engineering results
d <- readRDS("out/res.rds")
plot(d$samples[,1],type="l")
dd <- d$samples[1e5:2e5,]
apply( dd, 2, mean )
# > apply( dd, 2, mean )
# [1] 1.2361161 0.9054116 3.1729030 0.465244
```

# Fitting to incidence data
```{r}
rm( list=ls() )
country <- "Nepal"
library( deSolve )
source( "codes/params.R" )
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )

start <- c( 0.2, 1, 1, 1 )

library( adaptMCMC )

tic <- Sys.time()
res <- MCMC( p=log_posterior, n=1e5, init=start, scale=c(0.01,0.1,0.1,0.1), adapt=TRUE, acc.rate=0.234, fun=cholera_sirw, data=inc_obs, tstop=80*365, pyo=1e5 )

Sys.time() - tic

plot(res$samples[,1],type="l")

tstamp <- format( Sys.time(), "%Y%m%dT%H%M%S" )
saveRDS( res, paste0( "out/", country, "_fit_", tstamp, ".rds") )
```

# Vaccine impact evaluation
```{r}
rm( list=ls() )
country <- "Nepal"
source( "codes/params.R" ) #
source( "codes/func.R" )
library( Rcpp )
sourceCpp( "codes/cholera_sirw.cpp" )
# params <- c(1.3,5,1.8,0.4)

d <- readRDS( "out/20190723T174144.rds" )
samples <- d$samples[sample(80000:100000,20),]

scenario <- expand.grid( cov_vac = seq( 0, 1, 0.1 ),
                         vacc_campaign = TRUE )

res_10y <- data.frame( matrix( NA, nrow=nrow(scenario), ncol=nrow(samples) ) )
res_10y <- cbind( scenario, res_10y  )
tsteady <- 90*365 # in terms of year
dur_post_vacc <- 10*365
tstop <- tsteady + dur_post_vacc  
start_vacc_campaign <- tsteady
dur_vacc_campaign <- 14.0
stop_vacc_campaign <- start_vacc_campaign + dur_vacc_campaign
size_ref_pop <- 1e5
for( i in 1:nrow(scenario) ){
  cat( "i =", i, "\n" )
  cov_vacc_campaign <- vacc_campaign
  vacc_campaign<- scenario$
  for( j in 1:nrow(samples) ){
    cat( "j =", j, "\n" )
    res <- incidence( params=samples[ j, 1:4], fun=cholera_sirw, tstop=tstop )
    # cumulative incidence over dur_post_vacc days per ref_pop
    res_10y[ i, (j+ncol(scenario)) ] <- 
      ( sum(res$ci[round(tstop/365),]) - sum(res$ci[round(tsteady/365),]) ) / sum(res$pop[round(tsteady/365),])*size_ref_pop
  }
}



```

## Inside the incidence method

```{r}
library(coda)
chain<- mcmc(samp$samples)
summary(chain)
plot(chain)
library(BayesianTools)
correlationPlot(data.frame(chain))
combinedchains = mcmc.list(chain, chain2)
plot(combinedchains)
gelman.diag(combinedchains)
gelman.plot(combinedchains)

```


```{r}

```

#Parallel 
```{r}
library(adaptMCMC)
samp <- MCMC( log_posterior, n=1000, init=start, scale=c(0.005,0.1,0.1,0.1), adapt=FALSE)
samp_adt <- MCMC( p=log_posterior, n=2000, init=start, scale=c(0.01,0.2,0.2,0.2), adapt=TRUE, acc.rate=0.234 )
library(coda)
hist( samp_adt$samples[1000:2000,1] )
hist( samp_adt$samples[1000:2000,2] )
hist( samp_adt$samples[1000:2000,3] )
hist( samp_adt$samples[1000:2000,4] )
str(samp)
summary(samp_adt$samples)
plot( samp_adt$samples[,2] )

## ----------------------
## plot density and samples

x1 <- seq(-15, 15, length=80)
x2 <- seq(-15, 15, length=80)
x3 <- seq(-15, 15, length=80)
x4 <- seq(-15, 15, length=80)

d.banana <- matrix(apply(expand.grid(x1, x2), 1,  p.log), nrow=80)

par(mfrow=c(1,2))
image(x1, x2, exp(d.banana), col=cm.colors(60), asp=1, main="no adaption")
contour(x1, x2, exp(d.banana), add=TRUE, col=gray(0.6))
lines(samp.1$samples, type='b', pch=3)

image(x1, x2, exp(d.banana), col=cm.colors(60), asp=1, main="with adaption")
contour(x1, x2, exp(d.banana), add=TRUE, col=gray(0.6))
lines(samp.2$samples, type='b', pch=3)
```

```{r}
# out <- rk( y=yini, times=t_steps, func=derivs, parms=pars, method="rk45ck" )
# > class(out)
# [1] "deSolve" "matrix" 
class(out) <- "matrix" # without this, dplyr functions get error
out <- tbl_df( out )
colnames( out ) <- c( "t", "S", "I", "R" )
out <- gather( out, inf_status, num, -t )
out$inf_status <- factor( out$inf_status, levels=c("S","I","R") )

out <- filter( out, inf_status == "I" )

ggplot( out ) + 
    geom_line( aes( x=t, y=num, color=inf_status ) ) +
    geom_line( aes( x=t, y=num ), color="red" ) +
    scale_colour_manual( values=c(S="blue",I="red",R="green") ) +
    scale_y_continuous( limits=c(0,520) ) +
    scale_x_continuous( limits=c(0,30) ) +
    labs( x="Time (year)", y="Number of infected people" )
    labs( x="Time (year)", y="Number of infected people", color="Infection status" )
    theme( legend.position=c(0.85,0.45) ) +
    annotate( "text", label=paste0("beta == ", beta), parse=T, x=100, y=1000, size=4, colour="red" ) +
    annotate( "text", label=paste0("gamma == ", gamma), parse=T, x=122, y=1000, size=4, colour="red" )

# ggsave( "sir_i_bir_seas_10-24yr.png" )
```
